/*
* Author		: Ashish Kumar
* Created 		: 04-04-2016
* Version		: 3.0v
* Description		: The main tranlator program
* Modification log	:
*/

#include <ctype.h>
#include <stdio.h>
#include <vector>
#include <string>
#include <set>
#include <fstream>
#include <iostream>
#include <cstring>
#include <assert.h>
#include <stdlib.h>
#include "lpmln_parser.c"
#include "lpmln_lexer.cc"
#define YYCTYPE char

void perform_completion(ofstream &outfile, datacontainer &container) {
    outfile << "//Completion generated by translator\n";
    vector<typeimplication>::iterator rules_iterator;
    list<predicate>::const_iterator predicate_iterator;

    if(container.predicates.empty()) {
        outfile << "//No completion generated.\n";
    } else {
        for(predicate_iterator = container.predicatelist.begin(); predicate_iterator != container.predicatelist.end(); ++predicate_iterator) {
            predicate temp = *predicate_iterator; 
            string predicate  = temp.getname(); cout << "Predicate : " << predicate << endl;
            bool found = false;
            stack<string> bodies;
            for(rules_iterator = container.ruleslist.begin(); rules_iterator != container.ruleslist.end(); ++rules_iterator) {
                typeimplication temp = *rules_iterator;
                //print(temp);
                if(predicate.compare(temp.head.clauses()) == 0) {
                    found = true;
                    bodies.push(temp.body.conjuncts());
                }
            }

            if(found == false) {
                outfile << SYMBOL_NEGATION << temp.nameandvariable() << SYMBOL_PERIOD << endl;
            } else {

                outfile << predicate << SYMBOL_SPACE << SYMBOL_IMPLICATION;
                while(!bodies.empty()) {
                    if(bodies.size() == 1) {
                        outfile <<  SYMBOL_SPACE << bodies.top();
                    } else {
                        outfile << SYMBOL_SPACE  << bodies.top() << SYMBOL_SPACE << SYMBOL_DISJUNCTION;
                    }
                    bodies.pop();
                }
                outfile << SYMBOL_PERIOD << endl;
            }
        }
    }
}

int main(int argc, char* argv[])
{
    FILE *fi;
    ofstream outfile;

    if(argc != 3) {
        cout << "correct invocation ./lpmln_to_mln <source_file_name> <destination_file_name>." << endl;
    } else {
        fi = fopen(argv[1], "r");
	outfile.open(argv[2]);
        if(fi) {
            fio input(fi);
            char * start = input.str;
            void *pParser = ParseAlloc( malloc );
            bool loopFlag = true;
            
            string last;
            datacontainer container;
            cout << "Parsing initiated." << endl;
            while(loopFlag) {
                token new_token = next_token(start);

                if(!(new_token.type == WHITESPACE)) {
                    new_token.last = last;
                    Parse(pParser, new_token.type, &new_token, &container);

                    last = new_token.text;
                    if(container.tokens.size() > 0 ) {
                        if(container.tokens.top().type == END_OF_FORMULA) {
                            container.tokens.pop();
                            if(container.rules.size() != 0) {
                                container.ruleslist.push_back(container.rules.top());
                                container.rules.pop();
                            }
                        }
                    }
                }
                start = new_token.next;

                outfile << new_token.text;
                if(new_token.type == FILE_END) {
                    loopFlag = false;
                }
            }

            ParseFree(pParser, free );
            cout << "End of file reached. Total rules : ";
	    perform_completion(outfile, container);
            cout << "Completion generated." << endl;
        } else {
            cout << "Invalid file name." << endl;
        }
        fclose(fi);
        outfile.close();
   }
    return 0;
}
